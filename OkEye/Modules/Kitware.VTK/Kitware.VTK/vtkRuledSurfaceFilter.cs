using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK;

/// <summary>
///    vtkRuledSurfaceFilter
/// </summary>
/// <remarks>
///    generates a surface from a set of lines
///
/// vtkRuledSurfaceFilter is a filter that generates a surface from a set of
/// lines. The lines are assumed to be "parallel" in the sense that they do
/// not intersect and remain somewhat close to one another. A surface is
/// generated by connecting the points defining each pair of lines with
/// straight lines. This creates a strip for each pair of lines (i.e., a
/// triangulation is created from two generating lines). The filter can handle
/// an arbitrary number of lines, with lines i and i+1 assumed connected.
/// Note that there are several different approaches for creating the ruled
/// surface, the method for creating the surface can either use the input
/// points or resample from the polylines (using a user-specified resolution).
///
/// This filter offers some other important features. A DistanceFactor ivar is
/// used to decide when two lines are too far apart to connect. (The factor is
/// a multiple of the distance between the first two points of the two lines
/// defining the strip.) If the distance between the two generating lines
/// becomes too great, then the surface is not generated in that
/// region. (Note: if the lines separate and then merge, then a hole can be
/// generated in the surface.) In addition, the Offset and OnRation ivars can
/// be used to create nifty striped surfaces. Closed surfaces (e.g., tubes) can
/// be created by setting the CloseSurface ivar. (The surface can be closed
/// in the other direction by repeating the first and last point in the
/// polylines defining the surface.)
///
/// An important use of this filter is to combine it with vtkStreamTracer to
/// generate stream surfaces. It can also be used to create surfaces from
/// contours.
///
/// @warning
/// The number of lines must be greater than two if a surface is to be
/// generated.  sides (i.e., a ribbon), use vtkRibbonFilter.
///
/// </remarks>
/// <seealso>
///
/// vtkRibbonFilter vtkStreamTracer
/// </seealso>
public class vtkRuledSurfaceFilter : vtkPolyDataAlgorithm
{
	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new const string MRFullTypeName = "Kitware.VTK.vtkRuledSurfaceFilter";

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new static readonly string MRClassNameKey;

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	static vtkRuledSurfaceFilter()
	{
		MRClassNameKey = "class vtkRuledSurfaceFilter";
		Methods.RegisterType(Assembly.GetExecutingAssembly(), MRClassNameKey, Type.GetType("Kitware.VTK.vtkRuledSurfaceFilter"));
	}

	/// <summary>
	/// Automatically generated constructor - called from generated code.
	/// DO NOT call directly.
	/// </summary>
	public vtkRuledSurfaceFilter(IntPtr rawCppThis, bool callDisposalMethod, bool strong)
		: base(rawCppThis, callDisposalMethod, strong)
	{
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkRuledSurfaceFilter_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Construct object with OnRatio=1, Offset=0. DistanceFactor=3.0,
	/// CloseSurface off, and PassLines off.
	/// </summary>
	public new static vtkRuledSurfaceFilter New()
	{
		vtkRuledSurfaceFilter result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkRuledSurfaceFilter_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkRuledSurfaceFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	/// <summary>
	/// Construct object with OnRatio=1, Offset=0. DistanceFactor=3.0,
	/// CloseSurface off, and PassLines off.
	/// </summary>
	public vtkRuledSurfaceFilter()
		: base(IntPtr.Zero, callDisposalMethod: false, strong: false)
	{
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr rawCppThis = vtkRuledSurfaceFilter_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		SetCppThis(rawCppThis, callDisposalMethod: true, (mteStatus != 0 && rawRefCount >= 2) ? true : false);
	}

	/// <summary>
	/// Automatically generated protected Dispose method - called from
	/// public Dispose or the C# destructor. DO NOT call directly.
	/// </summary>
	protected override void Dispose(bool disposing)
	{
		base.Dispose(disposing);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_CloseSurfaceOff_01(HandleRef pThis);

	/// <summary>
	/// Indicate whether the surface is to be closed. If this boolean is
	/// on, then the first and last polyline are used to generate a stripe
	/// that closes the surface. (Note: to close the surface in the other
	/// direction, repeat the first point in the polyline as the last
	/// point in the polyline.)
	/// </summary>
	public virtual void CloseSurfaceOff()
	{
		vtkRuledSurfaceFilter_CloseSurfaceOff_01(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_CloseSurfaceOn_02(HandleRef pThis);

	/// <summary>
	/// Indicate whether the surface is to be closed. If this boolean is
	/// on, then the first and last polyline are used to generate a stripe
	/// that closes the surface. (Note: to close the surface in the other
	/// direction, repeat the first point in the polyline as the last
	/// point in the polyline.)
	/// </summary>
	public virtual void CloseSurfaceOn()
	{
		vtkRuledSurfaceFilter_CloseSurfaceOn_02(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetCloseSurface_03(HandleRef pThis);

	/// <summary>
	/// Indicate whether the surface is to be closed. If this boolean is
	/// on, then the first and last polyline are used to generate a stripe
	/// that closes the surface. (Note: to close the surface in the other
	/// direction, repeat the first point in the polyline as the last
	/// point in the polyline.)
	/// </summary>
	public virtual int GetCloseSurface()
	{
		return vtkRuledSurfaceFilter_GetCloseSurface_03(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkRuledSurfaceFilter_GetDistanceFactor_04(HandleRef pThis);

	/// <summary>
	/// Set/Get the factor that controls tearing of the surface.
	/// </summary>
	public virtual double GetDistanceFactor()
	{
		return vtkRuledSurfaceFilter_GetDistanceFactor_04(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkRuledSurfaceFilter_GetDistanceFactorMaxValue_05(HandleRef pThis);

	/// <summary>
	/// Set/Get the factor that controls tearing of the surface.
	/// </summary>
	public virtual double GetDistanceFactorMaxValue()
	{
		return vtkRuledSurfaceFilter_GetDistanceFactorMaxValue_05(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkRuledSurfaceFilter_GetDistanceFactorMinValue_06(HandleRef pThis);

	/// <summary>
	/// Set/Get the factor that controls tearing of the surface.
	/// </summary>
	public virtual double GetDistanceFactorMinValue()
	{
		return vtkRuledSurfaceFilter_GetDistanceFactorMinValue_06(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkRuledSurfaceFilter_GetNumberOfGenerationsFromBase_07(HandleRef pThis, string type);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public override long GetNumberOfGenerationsFromBase(string type)
	{
		return vtkRuledSurfaceFilter_GetNumberOfGenerationsFromBase_07(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkRuledSurfaceFilter_GetNumberOfGenerationsFromBaseType_08(string type);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public new static long GetNumberOfGenerationsFromBaseType(string type)
	{
		return vtkRuledSurfaceFilter_GetNumberOfGenerationsFromBaseType_08(type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOffset_09(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. The offset sets the
	/// first stripe that is visible. Offset is generally used with
	/// OnRatio to create nifty striping effects.
	/// </summary>
	public virtual int GetOffset()
	{
		return vtkRuledSurfaceFilter_GetOffset_09(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOffsetMaxValue_10(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. The offset sets the
	/// first stripe that is visible. Offset is generally used with
	/// OnRatio to create nifty striping effects.
	/// </summary>
	public virtual int GetOffsetMaxValue()
	{
		return vtkRuledSurfaceFilter_GetOffsetMaxValue_10(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOffsetMinValue_11(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. The offset sets the
	/// first stripe that is visible. Offset is generally used with
	/// OnRatio to create nifty striping effects.
	/// </summary>
	public virtual int GetOffsetMinValue()
	{
		return vtkRuledSurfaceFilter_GetOffsetMinValue_11(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOnRatio_12(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. If OnRatio is greater
	/// than 1, then every nth strip is turned on, beginning with the Offset
	/// strip.
	/// </summary>
	public virtual int GetOnRatio()
	{
		return vtkRuledSurfaceFilter_GetOnRatio_12(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOnRatioMaxValue_13(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. If OnRatio is greater
	/// than 1, then every nth strip is turned on, beginning with the Offset
	/// strip.
	/// </summary>
	public virtual int GetOnRatioMaxValue()
	{
		return vtkRuledSurfaceFilter_GetOnRatioMaxValue_13(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOnRatioMinValue_14(HandleRef pThis);

	/// <summary>
	/// Control the striping of the ruled surface. If OnRatio is greater
	/// than 1, then every nth strip is turned on, beginning with the Offset
	/// strip.
	/// </summary>
	public virtual int GetOnRatioMinValue()
	{
		return vtkRuledSurfaceFilter_GetOnRatioMinValue_14(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetOrientLoops_15(HandleRef pThis);

	/// <summary>
	/// Indicate whether the starting points of the loops need to be determined.
	/// If set to 0, then its assumes that the 0th point of each loop should be
	/// always connected
	/// By default the loops are not oriented.
	/// </summary>
	public virtual int GetOrientLoops()
	{
		return vtkRuledSurfaceFilter_GetOrientLoops_15(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetPassLines_16(HandleRef pThis);

	/// <summary>
	/// Indicate whether the generating lines are to be passed to the output.
	/// By default lines are not passed to the output.
	/// </summary>
	public virtual int GetPassLines()
	{
		return vtkRuledSurfaceFilter_GetPassLines_16(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkRuledSurfaceFilter_GetResolution_17(HandleRef pThis);

	/// <summary>
	/// If the ruled surface generation mode is RESAMPLE, then these parameters
	/// are used to determine the resample rate. Resolution[0] defines the
	/// resolution in the direction of the polylines; Resolution[1] defines
	/// the resolution across the polylines (i.e., direction orthogonal to
	/// Resolution[0]).
	/// </summary>
	public virtual int[] GetResolution()
	{
		IntPtr intPtr = vtkRuledSurfaceFilter_GetResolution_17(GetCppThis());
		int[] array = null;
		if (IntPtr.Zero != intPtr)
		{
			array = new int[2];
			Marshal.Copy(intPtr, array, 0, array.Length);
		}
		return array;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_GetResolution_18(HandleRef pThis, IntPtr data);

	/// <summary>
	/// If the ruled surface generation mode is RESAMPLE, then these parameters
	/// are used to determine the resample rate. Resolution[0] defines the
	/// resolution in the direction of the polylines; Resolution[1] defines
	/// the resolution across the polylines (i.e., direction orthogonal to
	/// Resolution[0]).
	/// </summary>
	public virtual void GetResolution(IntPtr data)
	{
		vtkRuledSurfaceFilter_GetResolution_18(GetCppThis(), data);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetRuledMode_19(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public virtual int GetRuledMode()
	{
		return vtkRuledSurfaceFilter_GetRuledMode_19(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkRuledSurfaceFilter_GetRuledModeAsString_20(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public string GetRuledModeAsString()
	{
		return Marshal.PtrToStringAnsi(vtkRuledSurfaceFilter_GetRuledModeAsString_20(GetCppThis()));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetRuledModeMaxValue_21(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public virtual int GetRuledModeMaxValue()
	{
		return vtkRuledSurfaceFilter_GetRuledModeMaxValue_21(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_GetRuledModeMinValue_22(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public virtual int GetRuledModeMinValue()
	{
		return vtkRuledSurfaceFilter_GetRuledModeMinValue_22(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_IsA_23(HandleRef pThis, string type);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public override int IsA(string type)
	{
		return vtkRuledSurfaceFilter_IsA_23(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkRuledSurfaceFilter_IsTypeOf_24(string type);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public new static int IsTypeOf(string type)
	{
		return vtkRuledSurfaceFilter_IsTypeOf_24(type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkRuledSurfaceFilter_NewInstance_26(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public new vtkRuledSurfaceFilter NewInstance()
	{
		vtkRuledSurfaceFilter result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkRuledSurfaceFilter_NewInstance_26(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkRuledSurfaceFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_OrientLoopsOff_27(HandleRef pThis);

	/// <summary>
	/// Indicate whether the starting points of the loops need to be determined.
	/// If set to 0, then its assumes that the 0th point of each loop should be
	/// always connected
	/// By default the loops are not oriented.
	/// </summary>
	public virtual void OrientLoopsOff()
	{
		vtkRuledSurfaceFilter_OrientLoopsOff_27(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_OrientLoopsOn_28(HandleRef pThis);

	/// <summary>
	/// Indicate whether the starting points of the loops need to be determined.
	/// If set to 0, then its assumes that the 0th point of each loop should be
	/// always connected
	/// By default the loops are not oriented.
	/// </summary>
	public virtual void OrientLoopsOn()
	{
		vtkRuledSurfaceFilter_OrientLoopsOn_28(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_PassLinesOff_29(HandleRef pThis);

	/// <summary>
	/// Indicate whether the generating lines are to be passed to the output.
	/// By default lines are not passed to the output.
	/// </summary>
	public virtual void PassLinesOff()
	{
		vtkRuledSurfaceFilter_PassLinesOff_29(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_PassLinesOn_30(HandleRef pThis);

	/// <summary>
	/// Indicate whether the generating lines are to be passed to the output.
	/// By default lines are not passed to the output.
	/// </summary>
	public virtual void PassLinesOn()
	{
		vtkRuledSurfaceFilter_PassLinesOn_30(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkRuledSurfaceFilter_SafeDownCast_31(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	///             Undocumented Block
	/// </summary>
	public new static vtkRuledSurfaceFilter SafeDownCast(vtkObjectBase o)
	{
		vtkRuledSurfaceFilter vtkRuledSurfaceFilter2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkRuledSurfaceFilter_SafeDownCast_31(o?.GetCppThis() ?? default(HandleRef), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkRuledSurfaceFilter2 = (vtkRuledSurfaceFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkRuledSurfaceFilter2.Register(null);
			}
		}
		return vtkRuledSurfaceFilter2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetCloseSurface_32(HandleRef pThis, int _arg);

	/// <summary>
	/// Indicate whether the surface is to be closed. If this boolean is
	/// on, then the first and last polyline are used to generate a stripe
	/// that closes the surface. (Note: to close the surface in the other
	/// direction, repeat the first point in the polyline as the last
	/// point in the polyline.)
	/// </summary>
	public virtual void SetCloseSurface(int _arg)
	{
		vtkRuledSurfaceFilter_SetCloseSurface_32(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetDistanceFactor_33(HandleRef pThis, double _arg);

	/// <summary>
	/// Set/Get the factor that controls tearing of the surface.
	/// </summary>
	public virtual void SetDistanceFactor(double _arg)
	{
		vtkRuledSurfaceFilter_SetDistanceFactor_33(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetOffset_34(HandleRef pThis, int _arg);

	/// <summary>
	/// Control the striping of the ruled surface. The offset sets the
	/// first stripe that is visible. Offset is generally used with
	/// OnRatio to create nifty striping effects.
	/// </summary>
	public virtual void SetOffset(int _arg)
	{
		vtkRuledSurfaceFilter_SetOffset_34(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetOnRatio_35(HandleRef pThis, int _arg);

	/// <summary>
	/// Control the striping of the ruled surface. If OnRatio is greater
	/// than 1, then every nth strip is turned on, beginning with the Offset
	/// strip.
	/// </summary>
	public virtual void SetOnRatio(int _arg)
	{
		vtkRuledSurfaceFilter_SetOnRatio_35(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetOrientLoops_36(HandleRef pThis, int _arg);

	/// <summary>
	/// Indicate whether the starting points of the loops need to be determined.
	/// If set to 0, then its assumes that the 0th point of each loop should be
	/// always connected
	/// By default the loops are not oriented.
	/// </summary>
	public virtual void SetOrientLoops(int _arg)
	{
		vtkRuledSurfaceFilter_SetOrientLoops_36(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetPassLines_37(HandleRef pThis, int _arg);

	/// <summary>
	/// Indicate whether the generating lines are to be passed to the output.
	/// By default lines are not passed to the output.
	/// </summary>
	public virtual void SetPassLines(int _arg)
	{
		vtkRuledSurfaceFilter_SetPassLines_37(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetResolution_38(HandleRef pThis, int _arg1, int _arg2);

	/// <summary>
	/// If the ruled surface generation mode is RESAMPLE, then these parameters
	/// are used to determine the resample rate. Resolution[0] defines the
	/// resolution in the direction of the polylines; Resolution[1] defines
	/// the resolution across the polylines (i.e., direction orthogonal to
	/// Resolution[0]).
	/// </summary>
	public virtual void SetResolution(int _arg1, int _arg2)
	{
		vtkRuledSurfaceFilter_SetResolution_38(GetCppThis(), _arg1, _arg2);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetResolution_39(HandleRef pThis, IntPtr _arg);

	/// <summary>
	/// If the ruled surface generation mode is RESAMPLE, then these parameters
	/// are used to determine the resample rate. Resolution[0] defines the
	/// resolution in the direction of the polylines; Resolution[1] defines
	/// the resolution across the polylines (i.e., direction orthogonal to
	/// Resolution[0]).
	/// </summary>
	public void SetResolution(IntPtr _arg)
	{
		vtkRuledSurfaceFilter_SetResolution_39(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetRuledMode_40(HandleRef pThis, int _arg);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public virtual void SetRuledMode(int _arg)
	{
		vtkRuledSurfaceFilter_SetRuledMode_40(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetRuledModeToPointWalk_41(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public void SetRuledModeToPointWalk()
	{
		vtkRuledSurfaceFilter_SetRuledModeToPointWalk_41(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkRuledSurfaceFilter_SetRuledModeToResample_42(HandleRef pThis);

	/// <summary>
	/// Set the mode by which to create the ruled surface. (Dramatically
	/// different results are possible depending on the chosen mode.) The
	/// resample mode evenly resamples the polylines (based on length) and
	/// generates triangle strips. The point walk mode uses the existing
	/// points and walks around the polyline using existing points.
	/// </summary>
	public void SetRuledModeToResample()
	{
		vtkRuledSurfaceFilter_SetRuledModeToResample_42(GetCppThis());
	}
}
