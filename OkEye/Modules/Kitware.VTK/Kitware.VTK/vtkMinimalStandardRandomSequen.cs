using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK;

/// <summary>
///    vtkMinimalStandardRandomSequence
/// </summary>
/// <remarks>
///    Park and Miller Sequence of pseudo random numbers
///
/// vtkMinimalStandardRandomSequence is a sequence of statistically independent
/// pseudo random numbers uniformly distributed between 0.0 and 1.0.
///
/// The sequence is generated by a prime modulus multiplicative linear
/// congruential generator (PMMLCG) or "Lehmer generator" with multiplier 16807
/// and prime modulus 2^(31)-1. The authors calls it
/// "minimal standard random number generator"
///
/// ref: "Random Number Generators: Good Ones are Hard to Find,"
/// by Stephen K. Park and Keith W. Miller in Communications of the ACM,
/// 31, 10 (Oct. 1988) pp. 1192-1201.
/// Code is at page 1195, "Integer version 2"
///
/// Correctness test is described in first column, page 1195:
/// A seed of 1 at step 1 should give a seed of 1043618065 at step 10001.
/// </remarks>
public class vtkMinimalStandardRandomSequence : vtkRandomSequence
{
	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new const string MRFullTypeName = "Kitware.VTK.vtkMinimalStandardRandomSequence";

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new static readonly string MRClassNameKey;

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	static vtkMinimalStandardRandomSequence()
	{
		MRClassNameKey = "class vtkMinimalStandardRandomSequence";
		Methods.RegisterType(Assembly.GetExecutingAssembly(), MRClassNameKey, Type.GetType("Kitware.VTK.vtkMinimalStandardRandomSequence"));
	}

	/// <summary>
	/// Automatically generated constructor - called from generated code.
	/// DO NOT call directly.
	/// </summary>
	public vtkMinimalStandardRandomSequence(IntPtr rawCppThis, bool callDisposalMethod, bool strong)
		: base(rawCppThis, callDisposalMethod, strong)
	{
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkMinimalStandardRandomSequence_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public new static vtkMinimalStandardRandomSequence New()
	{
		vtkMinimalStandardRandomSequence result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkMinimalStandardRandomSequence_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkMinimalStandardRandomSequence)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public vtkMinimalStandardRandomSequence()
		: base(IntPtr.Zero, callDisposalMethod: false, strong: false)
	{
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr rawCppThis = vtkMinimalStandardRandomSequence_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		SetCppThis(rawCppThis, callDisposalMethod: true, (mteStatus != 0 && rawRefCount >= 2) ? true : false);
	}

	/// <summary>
	/// Automatically generated protected Dispose method - called from
	/// public Dispose or the C# destructor. DO NOT call directly.
	/// </summary>
	protected override void Dispose(bool disposing)
	{
		base.Dispose(disposing);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkMinimalStandardRandomSequence_GetNextRangeValue_01(HandleRef pThis, double rangeMin, double rangeMax);

	/// <summary>
	/// Get the next value in the sequence within a range.
	///
	/// \see vtkMinimalStandardRandomSequence::GetRangeValue
	/// </summary>
	public double GetNextRangeValue(double rangeMin, double rangeMax)
	{
		return vtkMinimalStandardRandomSequence_GetNextRangeValue_01(GetCppThis(), rangeMin, rangeMax);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkMinimalStandardRandomSequence_GetNumberOfGenerationsFromBase_02(HandleRef pThis, string type);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public override long GetNumberOfGenerationsFromBase(string type)
	{
		return vtkMinimalStandardRandomSequence_GetNumberOfGenerationsFromBase_02(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkMinimalStandardRandomSequence_GetNumberOfGenerationsFromBaseType_03(string type);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public new static long GetNumberOfGenerationsFromBaseType(string type)
	{
		return vtkMinimalStandardRandomSequence_GetNumberOfGenerationsFromBaseType_03(type);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkMinimalStandardRandomSequence_GetRangeValue_04(HandleRef pThis, double rangeMin, double rangeMax);

	/// <summary>
	/// Convenient method to return a value in a specific range from the
	/// range [0,1. There is an initial implementation that can be overridden
	/// by a subclass.
	/// There is no pre-condition on the range:
	/// - it can be in increasing order: rangeMin&lt;rangeMax
	/// - it can be empty: rangeMin=rangeMax
	/// - it can be in decreasing order: rangeMin&gt;rangeMax
	/// \post result_in_range:
	/// (rangeMin&lt;=rangeMax &amp;&amp; result&gt;=rangeMin &amp;&amp; result&lt;=rangeMax)
	/// || (rangeMax&lt;=rangeMin &amp;&amp; result&gt;=rangeMax &amp;&amp; result&lt;=rangeMin)
	/// </summary>
	public virtual double GetRangeValue(double rangeMin, double rangeMax)
	{
		return vtkMinimalStandardRandomSequence_GetRangeValue_04(GetCppThis(), rangeMin, rangeMax);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkMinimalStandardRandomSequence_GetSeed_05(HandleRef pThis);

	/// <summary>
	/// Get the seed of the random sequence.
	/// Only useful for writing correctness test.
	/// </summary>
	public int GetSeed()
	{
		return vtkMinimalStandardRandomSequence_GetSeed_05(GetCppThis());
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkMinimalStandardRandomSequence_GetValue_06(HandleRef pThis);

	/// <summary>
	/// Current value
	/// \post unit_range: result&gt;=0.0 &amp;&amp; result&lt;=1.0
	/// </summary>
	public override double GetValue()
	{
		return vtkMinimalStandardRandomSequence_GetValue_06(GetCppThis());
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkMinimalStandardRandomSequence_Initialize_07(HandleRef pThis, uint seed);

	/// <summary>
	/// Satisfy general API of vtkRandomSequence superclass. Initialize the
	/// sequence with a seed.
	/// </summary>
	public override void Initialize(uint seed)
	{
		vtkMinimalStandardRandomSequence_Initialize_07(GetCppThis(), seed);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkMinimalStandardRandomSequence_IsA_08(HandleRef pThis, string type);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public override int IsA(string type)
	{
		return vtkMinimalStandardRandomSequence_IsA_08(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkMinimalStandardRandomSequence_IsTypeOf_09(string type);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public new static int IsTypeOf(string type)
	{
		return vtkMinimalStandardRandomSequence_IsTypeOf_09(type);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkMinimalStandardRandomSequence_NewInstance_11(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public new vtkMinimalStandardRandomSequence NewInstance()
	{
		vtkMinimalStandardRandomSequence result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkMinimalStandardRandomSequence_NewInstance_11(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkMinimalStandardRandomSequence)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkMinimalStandardRandomSequence_Next_12(HandleRef pThis);

	/// <summary>
	/// Move to the next number in the random sequence.
	/// </summary>
	public override void Next()
	{
		vtkMinimalStandardRandomSequence_Next_12(GetCppThis());
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkMinimalStandardRandomSequence_SafeDownCast_13(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods for instantiation, type information, and printing.
	/// </summary>
	public new static vtkMinimalStandardRandomSequence SafeDownCast(vtkObjectBase o)
	{
		vtkMinimalStandardRandomSequence vtkMinimalStandardRandomSequence2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkMinimalStandardRandomSequence_SafeDownCast_13(o?.GetCppThis() ?? default(HandleRef), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkMinimalStandardRandomSequence2 = (vtkMinimalStandardRandomSequence)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkMinimalStandardRandomSequence2.Register(null);
			}
		}
		return vtkMinimalStandardRandomSequence2;
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkMinimalStandardRandomSequence_SetSeed_14(HandleRef pThis, int value);

	/// <summary>
	/// Set the seed of the random sequence.
	/// The following pre-condition is stated page 1197, second column:
	/// valid_seed: value&gt;=1 &amp;&amp; value&lt;=2147483646
	/// 2147483646=(2^31)-2
	/// This method does not have this criterium as a pre-condition (ie it will
	/// not fail if an incorrect seed value is passed) but the value is silently
	/// changed to fit in the valid range [1,2147483646].
	/// 2147483646 is added to a null or negative value.
	/// 2147483647 is changed to be 1 (ie 2147483646 is subtracted).
	/// Implementation note: it also performs 3 calls to Next() to avoid the
	/// bad property that the first random number is proportional to the seed
	/// value.
	/// </summary>
	public void SetSeed(int value)
	{
		vtkMinimalStandardRandomSequence_SetSeed_14(GetCppThis(), value);
	}

	[DllImport("Kitware.VTK.CommonCore.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkMinimalStandardRandomSequence_SetSeedOnly_15(HandleRef pThis, int value);

	/// <summary>
	/// Set the seed of the random sequence. There is no extra internal
	/// adjustment. Only useful for writing correctness test.
	/// The following pre-condition is stated page 1197, second column
	/// 2147483646=(2^31)-2
	/// This method does not have this criterium as a pre-condition (ie it will
	/// not fail if an incorrect seed value is passed) but the value is silently
	/// changed to fit in the valid range [1,2147483646].
	/// 2147483646 is added to a null or negative value.
	/// 2147483647 is changed to be 1 (ie 2147483646 is subtracted).
	/// </summary>
	public void SetSeedOnly(int value)
	{
		vtkMinimalStandardRandomSequence_SetSeedOnly_15(GetCppThis(), value);
	}
}
