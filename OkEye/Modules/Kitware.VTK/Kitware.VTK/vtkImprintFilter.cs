using System;
using System.Reflection;
using System.Runtime.InteropServices;
using Kitware.mummy.Runtime;

namespace Kitware.VTK;

/// <summary>
///    vtkImprintFilter
/// </summary>
/// <remarks>
///    Imprint the contact surface of one object onto another surface
///
/// This filter imprints the contact surface of one vtkPolyData mesh onto
/// a second, input vtkPolyData mesh. There are two inputs to the filter:
/// the target, which is the surface to be imprinted, and the imprint, which
/// is the object imprinting the target.
///
/// A high level overview of the algorithm is as follows. 1) The target cells
/// are segregated into two subsets: those that may intersect the imprint
/// surface (the candidate cells determined by bounding box checks), and those
/// that do not. 2) The non-candidates are sent to the output, the candidate
/// intersection cells are further processed - eventually they will be
/// triangulated as a result of contact with the imprint, with the result of
/// the triangulation appended to the output. 3) The imprint points are projected
/// onto the candidate cells, determining a classification (on a target point,
/// on a target edge, interior to a target cell, outside the target).  4) The
/// non-outside imprint points are associated with one or more target cells.
/// 5) The imprint edges are intersected with the target cell edges, producing
/// additional points associated with the the candidate cells, as well as
/// "fragments" or portions of edges associated with the candidate target
/// cells. 6) On a per-candidate-target-cell basis, the points and edge
/// fragments associated with that cell are used to triangulate the cell.
/// 7) Finally, the triangulated target cells are appended to the output.
///
/// Several options exist to specify how to produce an output cell data array
/// that indicates whether the output cells are in the imprinted area. If
/// enabled, this output vtkSignedCharArray will have a value=1 for cells that
/// are in the imprinted area. Otherwise, the value=0 is indicating the cell
/// is not in contact with the imprinted area. The name of this cell data
/// array is "ImprintedCells".
///
/// The filter also has the option to pass through and generate point and cell
/// data.  If PassCellData is enabled, then the cell data associated with the
/// cropped cells, or cells passed through from the input mesh, are passed
/// through to the output. If PassPointData is enabled, then in similar
/// fashion the point data is passed through; however new points generated by
/// intersection may have point data interpolated in one of two ways. First,
/// the target mesh edges are interpolated at the new intersection points to
/// generate point data, or the imprint edges are interpolated at the new
/// intersection points to generate point data. Note: for PassPointData and
/// point interpolation to function, the filter requires that the point data
/// attributes (from the target mesh and imprint mesh) are exactly the
/// same. If they are not, then a set intersection operation is performed that
/// uses the point data arrays common to both the target and imprint meshes.
///
/// Some notes:
/// -- The algorithm assumes that the input target and imprint cells are convex.
/// -- If performing a PROJECTED_IMPRINT, the output is the imprint mesh with
///    the point coordinates modified by projecting the imprint points onto
///    the target. If the profection of an imprint point onto the target is
///    unsuccessful, the imprint point coordinates are not modified.
/// -- If performing a MERGED_IMPRINT, the number of output points is
///    (numTargetPts + numImprintPts + numEdgeIntPts).
/// -- Not all of the output points may be used, for example if an imprint point
///    is coincident (within the tolerance) of a target point, the target point
///    replaces the imprint point.
/// -- Candidate cells which may reside within the bounding box of the imprint
///    but may not actually intersect the imprint will be appended to the output
///    without triangulation.
/// -- Candidate cells that are intersected will be triangulated: i.e., triangles
///    will be produced and appended to the output.
/// -- Triangulation requires combining the points and edge fragments associated
///    with each target candidate cell, as well as the candidate cell's defining
///    points and edges, to produce the final triangulation.
/// -- Portions of the algorithm are SMP threaded. For example, steps #1 and #2
///    (candidate segregation); point projection step #3; cell triangulation
///    step #6. Future implementations may further parallelize the algorithm.
/// -- The algorithm produces an output cell data array that indicates
///    which output cells are in the imprinted area. This vtkSignedCharArray
///    has a value=0 for cells that were originally target cells; a value=2
///    for output cells that are in the imprinted region; and a value=1 for
///    cells that are in the transition region (between target and imprinted
///    cells). The name of this cell data array is "ImprintedCells".
///
/// </remarks>
public class vtkImprintFilter : vtkPolyDataAlgorithm
{
	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public enum DebugOutput
	{
		/// <summary>enum member</summary>
		NO_DEBUG_OUTPUT,
		/// <summary>enum member</summary>
		TRIANGULATION_INPUT,
		/// <summary>enum member</summary>
		TRIANGULATION_OUTPUT
	}

	/// <summary>
	/// Specify a projection tolerance which controls how close the imprint
	/// surface must be to the target to successfully imprint the surface. This
	/// is an absolute value.
	/// </summary>
	public enum MergeTolType
	{
		/// <summary>enum member</summary>
		ABSOLUTE_TOLERANCE = 0,
		/// <summary>enum member</summary>
		RELATIVE_TO_MIN_EDGE_LENGTH = 2,
		/// <summary>enum member</summary>
		RELATIVE_TO_PROJECTION_TOLERANCE = 1
	}

	/// <summary>
	/// Indicate whether point data from the input target mesh and the imprint
	/// mesh are to be passed through and/or interpolated to the output mesh. By
	/// default, PassPointData is enabled. Note: both the input mesh points and
	/// the imprint points must have identical point data. Otherwise, a set
	/// intersection operation will be performed to process just the point data
	/// arrays common to both the mesh point data and imprint point data.
	/// </summary>
	public enum PointInterpolationType
	{
		/// <summary>enum member</summary>
		USE_IMPRINT_EDGES = 1,
		/// <summary>enum member</summary>
		USE_TARGET_EDGES = 0
	}

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public enum SpecifiedOutput
	{
		/// <summary>enum member</summary>
		IMPRINTED_CELLS = 1,
		/// <summary>enum member</summary>
		IMPRINTED_REGION = 3,
		/// <summary>enum member</summary>
		MERGED_IMPRINT = 5,
		/// <summary>enum member</summary>
		PROJECTED_IMPRINT = 2,
		/// <summary>enum member</summary>
		TARGET_CELLS = 0
	}

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new const string MRFullTypeName = "Kitware.VTK.vtkImprintFilter";

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	public new static readonly string MRClassNameKey;

	/// <summary>
	/// Automatically generated type registration mechanics.
	/// </summary>
	static vtkImprintFilter()
	{
		MRClassNameKey = "class vtkImprintFilter";
		Methods.RegisterType(Assembly.GetExecutingAssembly(), MRClassNameKey, Type.GetType("Kitware.VTK.vtkImprintFilter"));
	}

	/// <summary>
	/// Automatically generated constructor - called from generated code.
	/// DO NOT call directly.
	/// </summary>
	public vtkImprintFilter(IntPtr rawCppThis, bool callDisposalMethod, bool strong)
		: base(rawCppThis, callDisposalMethod, strong)
	{
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_New(ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public new static vtkImprintFilter New()
	{
		vtkImprintFilter result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public vtkImprintFilter()
		: base(IntPtr.Zero, callDisposalMethod: false, strong: false)
	{
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr rawCppThis = vtkImprintFilter_New(ref mteStatus, ref mteIndex, ref rawRefCount);
		SetCppThis(rawCppThis, callDisposalMethod: true, (mteStatus != 0 && rawRefCount >= 2) ? true : false);
	}

	/// <summary>
	/// Automatically generated protected Dispose method - called from
	/// public Dispose or the C# destructor. DO NOT call directly.
	/// </summary>
	protected override void Dispose(bool disposing)
	{
		base.Dispose(disposing);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_BoundaryEdgeInsertionOff_01(HandleRef pThis);

	/// <summary>
	/// Indicate whether to insert just the boundary edges of the imprint mesh
	/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
	/// used by exactly one cell.) If inserting boundary edges, the imprint
	/// operation is similar to a cookie cutter operation. By default, boundary
	/// edge insertion is off.
	/// </summary>
	public virtual void BoundaryEdgeInsertionOff()
	{
		vtkImprintFilter_BoundaryEdgeInsertionOff_01(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_BoundaryEdgeInsertionOn_02(HandleRef pThis);

	/// <summary>
	/// Indicate whether to insert just the boundary edges of the imprint mesh
	/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
	/// used by exactly one cell.) If inserting boundary edges, the imprint
	/// operation is similar to a cookie cutter operation. By default, boundary
	/// edge insertion is off.
	/// </summary>
	public virtual void BoundaryEdgeInsertionOn()
	{
		vtkImprintFilter_BoundaryEdgeInsertionOn_02(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern byte vtkImprintFilter_GetBoundaryEdgeInsertion_03(HandleRef pThis);

	/// <summary>
	/// Indicate whether to insert just the boundary edges of the imprint mesh
	/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
	/// used by exactly one cell.) If inserting boundary edges, the imprint
	/// operation is similar to a cookie cutter operation. By default, boundary
	/// edge insertion is off.
	/// </summary>
	public virtual bool GetBoundaryEdgeInsertion()
	{
		return (vtkImprintFilter_GetBoundaryEdgeInsertion_03(GetCppThis()) != 0) ? true : false;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkImprintFilter_GetDebugCellId_04(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual long GetDebugCellId()
	{
		return vtkImprintFilter_GetDebugCellId_04(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_GetDebugOutput_05(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Get the output data (in the second output, if the DebugOutput !=
	/// NO_DEBUG_OUTPUT).
	/// </summary>
	public vtkPolyData GetDebugOutput()
	{
		vtkPolyData vtkPolyData2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_GetDebugOutput_05(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkPolyData2 = (vtkPolyData)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkPolyData2.Register(null);
			}
		}
		return vtkPolyData2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetDebugOutputType_06(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual int GetDebugOutputType()
	{
		return vtkImprintFilter_GetDebugOutputType_06(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetDebugOutputTypeMaxValue_07(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual int GetDebugOutputTypeMaxValue()
	{
		return vtkImprintFilter_GetDebugOutputTypeMaxValue_07(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetDebugOutputTypeMinValue_08(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual int GetDebugOutputTypeMinValue()
	{
		return vtkImprintFilter_GetDebugOutputTypeMinValue_08(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_GetImprint_09(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Specify the a second vtkPolyData input which defines the surface mesh
	/// with which to imprint the target (i.e., the first input).
	/// </summary>
	public vtkDataObject GetImprint()
	{
		vtkDataObject vtkDataObject2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_GetImprint_09(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkDataObject2 = (vtkDataObject)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkDataObject2.Register(null);
			}
		}
		return vtkDataObject2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_GetImprintConnection_10(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Specify the a second vtkPolyData input connection which defines the
	/// surface mesh with which to imprint the target (the target is provided by
	/// the first input).
	/// </summary>
	public vtkAlgorithmOutput GetImprintConnection()
	{
		vtkAlgorithmOutput vtkAlgorithmOutput2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_GetImprintConnection_10(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkAlgorithmOutput2 = (vtkAlgorithmOutput)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkAlgorithmOutput2.Register(null);
			}
		}
		return vtkAlgorithmOutput2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetMergeTolerance_11(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual double GetMergeTolerance()
	{
		return vtkImprintFilter_GetMergeTolerance_11(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetMergeToleranceMaxValue_12(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual double GetMergeToleranceMaxValue()
	{
		return vtkImprintFilter_GetMergeToleranceMaxValue_12(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetMergeToleranceMinValue_13(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual double GetMergeToleranceMinValue()
	{
		return vtkImprintFilter_GetMergeToleranceMinValue_13(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetMergeToleranceType_14(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual int GetMergeToleranceType()
	{
		return vtkImprintFilter_GetMergeToleranceType_14(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetMergeToleranceTypeMaxValue_15(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual int GetMergeToleranceTypeMaxValue()
	{
		return vtkImprintFilter_GetMergeToleranceTypeMaxValue_15(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetMergeToleranceTypeMinValue_16(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual int GetMergeToleranceTypeMinValue()
	{
		return vtkImprintFilter_GetMergeToleranceTypeMinValue_16(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkImprintFilter_GetNumberOfGenerationsFromBase_17(HandleRef pThis, string type);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public override long GetNumberOfGenerationsFromBase(string type)
	{
		return vtkImprintFilter_GetNumberOfGenerationsFromBase_17(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern long vtkImprintFilter_GetNumberOfGenerationsFromBaseType_18(string type);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public new static long GetNumberOfGenerationsFromBaseType(string type)
	{
		return vtkImprintFilter_GetNumberOfGenerationsFromBaseType_18(type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetOutputType_19(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public virtual int GetOutputType()
	{
		return vtkImprintFilter_GetOutputType_19(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetOutputTypeMaxValue_20(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public virtual int GetOutputTypeMaxValue()
	{
		return vtkImprintFilter_GetOutputTypeMaxValue_20(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetOutputTypeMinValue_21(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public virtual int GetOutputTypeMinValue()
	{
		return vtkImprintFilter_GetOutputTypeMinValue_21(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern byte vtkImprintFilter_GetPassCellData_22(HandleRef pThis);

	/// <summary>
	/// Indicate whether cell data from the input target is to be passed through
	/// to the output mesh. By default, PassCellData is enabled.
	/// </summary>
	public virtual bool GetPassCellData()
	{
		return (vtkImprintFilter_GetPassCellData_22(GetCppThis()) != 0) ? true : false;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern byte vtkImprintFilter_GetPassPointData_23(HandleRef pThis);

	/// <summary>
	/// Indicate whether point data from the input target mesh and the imprint
	/// mesh are to be passed through and/or interpolated to the output mesh. By
	/// default, PassPointData is enabled. Note: both the input mesh points and
	/// the imprint points must have identical point data. Otherwise, a set
	/// intersection operation will be performed to process just the point data
	/// arrays common to both the mesh point data and imprint point data.
	/// </summary>
	public virtual bool GetPassPointData()
	{
		return (vtkImprintFilter_GetPassPointData_23(GetCppThis()) != 0) ? true : false;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetPointInterpolation_24(HandleRef pThis);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public virtual int GetPointInterpolation()
	{
		return vtkImprintFilter_GetPointInterpolation_24(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetPointInterpolationMaxValue_25(HandleRef pThis);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public virtual int GetPointInterpolationMaxValue()
	{
		return vtkImprintFilter_GetPointInterpolationMaxValue_25(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_GetPointInterpolationMinValue_26(HandleRef pThis);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public virtual int GetPointInterpolationMinValue()
	{
		return vtkImprintFilter_GetPointInterpolationMinValue_26(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_GetTarget_27(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Specify the first vtkPolyData input which defines the surface mesh to
	/// imprint (i.e., the taregt). The imprint surface is provided by the
	/// second input.
	/// </summary>
	public vtkDataObject GetTarget()
	{
		vtkDataObject vtkDataObject2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_GetTarget_27(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkDataObject2 = (vtkDataObject)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkDataObject2.Register(null);
			}
		}
		return vtkDataObject2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_GetTargetConnection_28(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Specify the first vtkPolyData input connection which defines the
	/// surface mesh to imprint (i.e., the target).
	/// </summary>
	public vtkAlgorithmOutput GetTargetConnection()
	{
		vtkAlgorithmOutput vtkAlgorithmOutput2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_GetTargetConnection_28(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkAlgorithmOutput2 = (vtkAlgorithmOutput)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkAlgorithmOutput2.Register(null);
			}
		}
		return vtkAlgorithmOutput2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetTolerance_29(HandleRef pThis);

	/// <summary>
	/// Specify a projection tolerance which controls how close the imprint
	/// surface must be to the target to successfully imprint the surface. This
	/// is an absolute value.
	/// </summary>
	public virtual double GetTolerance()
	{
		return vtkImprintFilter_GetTolerance_29(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetToleranceMaxValue_30(HandleRef pThis);

	/// <summary>
	/// Specify a projection tolerance which controls how close the imprint
	/// surface must be to the target to successfully imprint the surface. This
	/// is an absolute value.
	/// </summary>
	public virtual double GetToleranceMaxValue()
	{
		return vtkImprintFilter_GetToleranceMaxValue_30(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern double vtkImprintFilter_GetToleranceMinValue_31(HandleRef pThis);

	/// <summary>
	/// Specify a projection tolerance which controls how close the imprint
	/// surface must be to the target to successfully imprint the surface. This
	/// is an absolute value.
	/// </summary>
	public virtual double GetToleranceMinValue()
	{
		return vtkImprintFilter_GetToleranceMinValue_31(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern byte vtkImprintFilter_GetTriangulateOutput_32(HandleRef pThis);

	/// <summary>
	/// Indicate whether the output should be triangulated. By default (i.e.,
	/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
	/// target cell boundaries, will not be triangulated. (Cells in the
	/// transition region are always triangulated because they are frequently
	/// concave.)
	/// </summary>
	public virtual bool GetTriangulateOutput()
	{
		return (vtkImprintFilter_GetTriangulateOutput_32(GetCppThis()) != 0) ? true : false;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_IsA_33(HandleRef pThis, string type);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public override int IsA(string type)
	{
		return vtkImprintFilter_IsA_33(GetCppThis(), type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern int vtkImprintFilter_IsTypeOf_34(string type);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public new static int IsTypeOf(string type)
	{
		return vtkImprintFilter_IsTypeOf_34(type);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_NewInstance_36(HandleRef pThis, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public new vtkImprintFilter NewInstance()
	{
		vtkImprintFilter result = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_NewInstance_36(GetCppThis(), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			result = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var _);
		}
		return result;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_PassCellDataOff_37(HandleRef pThis);

	/// <summary>
	/// Indicate whether cell data from the input target is to be passed through
	/// to the output mesh. By default, PassCellData is enabled.
	/// </summary>
	public virtual void PassCellDataOff()
	{
		vtkImprintFilter_PassCellDataOff_37(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_PassCellDataOn_38(HandleRef pThis);

	/// <summary>
	/// Indicate whether cell data from the input target is to be passed through
	/// to the output mesh. By default, PassCellData is enabled.
	/// </summary>
	public virtual void PassCellDataOn()
	{
		vtkImprintFilter_PassCellDataOn_38(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_PassPointDataOff_39(HandleRef pThis);

	/// <summary>
	/// Indicate whether point data from the input target mesh and the imprint
	/// mesh are to be passed through and/or interpolated to the output mesh. By
	/// default, PassPointData is enabled. Note: both the input mesh points and
	/// the imprint points must have identical point data. Otherwise, a set
	/// intersection operation will be performed to process just the point data
	/// arrays common to both the mesh point data and imprint point data.
	/// </summary>
	public virtual void PassPointDataOff()
	{
		vtkImprintFilter_PassPointDataOff_39(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_PassPointDataOn_40(HandleRef pThis);

	/// <summary>
	/// Indicate whether point data from the input target mesh and the imprint
	/// mesh are to be passed through and/or interpolated to the output mesh. By
	/// default, PassPointData is enabled. Note: both the input mesh points and
	/// the imprint points must have identical point data. Otherwise, a set
	/// intersection operation will be performed to process just the point data
	/// arrays common to both the mesh point data and imprint point data.
	/// </summary>
	public virtual void PassPointDataOn()
	{
		vtkImprintFilter_PassPointDataOn_40(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern IntPtr vtkImprintFilter_SafeDownCast_41(HandleRef o, ref uint mteStatus, ref uint mteIndex, ref uint rawRefCount);

	/// <summary>
	/// Standard methods to instantiate, print and provide type information.
	/// </summary>
	public new static vtkImprintFilter SafeDownCast(vtkObjectBase o)
	{
		vtkImprintFilter vtkImprintFilter2 = null;
		uint mteStatus = 0u;
		uint mteIndex = uint.MaxValue;
		uint rawRefCount = 0u;
		IntPtr intPtr = vtkImprintFilter_SafeDownCast_41(o?.GetCppThis() ?? default(HandleRef), ref mteStatus, ref mteIndex, ref rawRefCount);
		if (IntPtr.Zero != intPtr)
		{
			vtkImprintFilter2 = (vtkImprintFilter)Methods.CreateWrappedObject(mteStatus, mteIndex, rawRefCount, intPtr, callDisposalMethod: true, out var found);
			if (found)
			{
				vtkImprintFilter2.Register(null);
			}
		}
		return vtkImprintFilter2;
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetBoundaryEdgeInsertion_42(HandleRef pThis, byte _arg);

	/// <summary>
	/// Indicate whether to insert just the boundary edges of the imprint mesh
	/// (i.e., do not insert the interior edges). (Boundary edges are mesh edges
	/// used by exactly one cell.) If inserting boundary edges, the imprint
	/// operation is similar to a cookie cutter operation. By default, boundary
	/// edge insertion is off.
	/// </summary>
	public virtual void SetBoundaryEdgeInsertion(bool _arg)
	{
		vtkImprintFilter_SetBoundaryEdgeInsertion_42(GetCppThis(), (byte)(_arg ? 1u : 0u));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetDebugCellId_43(HandleRef pThis, long _arg);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual void SetDebugCellId(long _arg)
	{
		vtkImprintFilter_SetDebugCellId_43(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetDebugOutputType_44(HandleRef pThis, int _arg);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public virtual void SetDebugOutputType(int _arg)
	{
		vtkImprintFilter_SetDebugOutputType_44(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetDebugOutputTypeToNoDebugOutput_45(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public void SetDebugOutputTypeToNoDebugOutput()
	{
		vtkImprintFilter_SetDebugOutputTypeToNoDebugOutput_45(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetDebugOutputTypeToTriangulationInput_46(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public void SetDebugOutputTypeToTriangulationInput()
	{
		vtkImprintFilter_SetDebugOutputTypeToTriangulationInput_46(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetDebugOutputTypeToTriangulationOutput_47(HandleRef pThis);

	/// <summary>
	/// The following methods support debugging. By default, NO_DEBUG_OUTPUT is
	/// produced and the second output of this filter is empty. If TRIANGULATION_INPUT
	/// is set, then the input points and edges contained by the target DebugCellId are
	/// output to the second output to this filter.  If TRIANGULATION_OUTPUT is
	/// set, then the output triangulation for the specified target cellId is
	/// placed in a second output to this filter.
	/// </summary>
	public void SetDebugOutputTypeToTriangulationOutput()
	{
		vtkImprintFilter_SetDebugOutputTypeToTriangulationOutput_47(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetImprintConnection_48(HandleRef pThis, HandleRef algOutput);

	/// <summary>
	/// Specify the a second vtkPolyData input connection which defines the
	/// surface mesh with which to imprint the target (the target is provided by
	/// the first input).
	/// </summary>
	public void SetImprintConnection(vtkAlgorithmOutput algOutput)
	{
		vtkImprintFilter_SetImprintConnection_48(GetCppThis(), algOutput?.GetCppThis() ?? default(HandleRef));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetImprintData_49(HandleRef pThis, HandleRef imprint);

	/// <summary>
	/// Specify the a second vtkPolyData input which defines the surface mesh
	/// with which to imprint the target (i.e., the first input).
	/// </summary>
	public void SetImprintData(vtkDataObject imprint)
	{
		vtkImprintFilter_SetImprintData_49(GetCppThis(), imprint?.GetCppThis() ?? default(HandleRef));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetMergeTolerance_50(HandleRef pThis, double _arg);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual void SetMergeTolerance(double _arg)
	{
		vtkImprintFilter_SetMergeTolerance_50(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetMergeToleranceType_51(HandleRef pThis, int _arg);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public virtual void SetMergeToleranceType(int _arg)
	{
		vtkImprintFilter_SetMergeToleranceType_51(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetMergeToleranceTypeToAbsolute_52(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public void SetMergeToleranceTypeToAbsolute()
	{
		vtkImprintFilter_SetMergeToleranceTypeToAbsolute_52(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetMergeToleranceTypeToMinEdge_53(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public void SetMergeToleranceTypeToMinEdge()
	{
		vtkImprintFilter_SetMergeToleranceTypeToMinEdge_53(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetMergeToleranceTypeToRelativeToProjection_54(HandleRef pThis);

	/// <summary>
	/// Specify a tolerance which is used to determine whether two points are
	/// considered coincident to one another. This is important when performing
	/// intersections and projections to reduce numerical issues.
	/// </summary>
	public void SetMergeToleranceTypeToRelativeToProjection()
	{
		vtkImprintFilter_SetMergeToleranceTypeToRelativeToProjection_54(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputType_55(HandleRef pThis, int _arg);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public virtual void SetOutputType(int _arg)
	{
		vtkImprintFilter_SetOutputType_55(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputTypeToImprintedCells_56(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public void SetOutputTypeToImprintedCells()
	{
		vtkImprintFilter_SetOutputTypeToImprintedCells_56(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputTypeToImprintedRegion_57(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public void SetOutputTypeToImprintedRegion()
	{
		vtkImprintFilter_SetOutputTypeToImprintedRegion_57(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputTypeToMergedImprint_58(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public void SetOutputTypeToMergedImprint()
	{
		vtkImprintFilter_SetOutputTypeToMergedImprint_58(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputTypeToProjectedImprint_59(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public void SetOutputTypeToProjectedImprint()
	{
		vtkImprintFilter_SetOutputTypeToProjectedImprint_59(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetOutputTypeToTargetCells_60(HandleRef pThis);

	/// <summary>
	/// Control what is output by the filter. This can be useful for debugging
	/// or to extract portions of the data. The choices are: TARGET_CELLS -
	/// output the target cells in contact (relative to the tolerance) of the
	/// imprint mesh; IMPRINTED_CELLS - output the target's imprinted cells
	/// after intersection and triangulation with the imprint mesh;
	/// PROJECTED_IMPRINT - project the imprint mesh onto the target mesh,
	/// modififying the imprint mesh point coordinates to lie on the target
	/// mesh; IMPRINTED_REGION - extract just the area of contact between the
	/// target and imprint; and MERGED_IMPRINT - merge the target and imprint
	/// mesh after the imprint operation. By default, MERGED_IMPRINT is
	/// produced.
	/// </summary>
	public void SetOutputTypeToTargetCells()
	{
		vtkImprintFilter_SetOutputTypeToTargetCells_60(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetPassCellData_61(HandleRef pThis, byte _arg);

	/// <summary>
	/// Indicate whether cell data from the input target is to be passed through
	/// to the output mesh. By default, PassCellData is enabled.
	/// </summary>
	public virtual void SetPassCellData(bool _arg)
	{
		vtkImprintFilter_SetPassCellData_61(GetCppThis(), (byte)(_arg ? 1u : 0u));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetPassPointData_62(HandleRef pThis, byte _arg);

	/// <summary>
	/// Indicate whether point data from the input target mesh and the imprint
	/// mesh are to be passed through and/or interpolated to the output mesh. By
	/// default, PassPointData is enabled. Note: both the input mesh points and
	/// the imprint points must have identical point data. Otherwise, a set
	/// intersection operation will be performed to process just the point data
	/// arrays common to both the mesh point data and imprint point data.
	/// </summary>
	public virtual void SetPassPointData(bool _arg)
	{
		vtkImprintFilter_SetPassPointData_62(GetCppThis(), (byte)(_arg ? 1u : 0u));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetPointInterpolation_63(HandleRef pThis, int _arg);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public virtual void SetPointInterpolation(int _arg)
	{
		vtkImprintFilter_SetPointInterpolation_63(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetPointInterpolationToImprintEdges_64(HandleRef pThis);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public void SetPointInterpolationToImprintEdges()
	{
		vtkImprintFilter_SetPointInterpolationToImprintEdges_64(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetPointInterpolationToTargetEdges_65(HandleRef pThis);

	/// <summary>
	/// If PassPointData is on, indicate how new point data is to generated at
	/// the intersection points between the input target mesh edges and the
	/// imprint edges By default, PointInterpolation is set to USE_TARGET_EDGES.
	/// </summary>
	public void SetPointInterpolationToTargetEdges()
	{
		vtkImprintFilter_SetPointInterpolationToTargetEdges_65(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetTargetConnection_66(HandleRef pThis, HandleRef algOutput);

	/// <summary>
	/// Specify the first vtkPolyData input connection which defines the
	/// surface mesh to imprint (i.e., the target).
	/// </summary>
	public void SetTargetConnection(vtkAlgorithmOutput algOutput)
	{
		vtkImprintFilter_SetTargetConnection_66(GetCppThis(), algOutput?.GetCppThis() ?? default(HandleRef));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetTargetData_67(HandleRef pThis, HandleRef target);

	/// <summary>
	/// Specify the first vtkPolyData input which defines the surface mesh to
	/// imprint (i.e., the taregt). The imprint surface is provided by the
	/// second input.
	/// </summary>
	public void SetTargetData(vtkDataObject target)
	{
		vtkImprintFilter_SetTargetData_67(GetCppThis(), target?.GetCppThis() ?? default(HandleRef));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetTolerance_68(HandleRef pThis, double _arg);

	/// <summary>
	/// Specify a projection tolerance which controls how close the imprint
	/// surface must be to the target to successfully imprint the surface. This
	/// is an absolute value.
	/// </summary>
	public virtual void SetTolerance(double _arg)
	{
		vtkImprintFilter_SetTolerance_68(GetCppThis(), _arg);
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_SetTriangulateOutput_69(HandleRef pThis, byte _arg);

	/// <summary>
	/// Indicate whether the output should be triangulated. By default (i.e.,
	/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
	/// target cell boundaries, will not be triangulated. (Cells in the
	/// transition region are always triangulated because they are frequently
	/// concave.)
	/// </summary>
	public virtual void SetTriangulateOutput(bool _arg)
	{
		vtkImprintFilter_SetTriangulateOutput_69(GetCppThis(), (byte)(_arg ? 1u : 0u));
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_TriangulateOutputOff_70(HandleRef pThis);

	/// <summary>
	/// Indicate whether the output should be triangulated. By default (i.e.,
	/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
	/// target cell boundaries, will not be triangulated. (Cells in the
	/// transition region are always triangulated because they are frequently
	/// concave.)
	/// </summary>
	public virtual void TriangulateOutputOff()
	{
		vtkImprintFilter_TriangulateOutputOff_70(GetCppThis());
	}

	[DllImport("Kitware.VTK.FiltersModeling.Unmanaged.dll", CallingConvention = CallingConvention.Cdecl)]
	internal static extern void vtkImprintFilter_TriangulateOutputOn_71(HandleRef pThis);

	/// <summary>
	/// Indicate whether the output should be triangulated. By default (i.e.,
	/// TriangulateOutputOff) the imprint cells, if not triangles nor intersect
	/// target cell boundaries, will not be triangulated. (Cells in the
	/// transition region are always triangulated because they are frequently
	/// concave.)
	/// </summary>
	public virtual void TriangulateOutputOn()
	{
		vtkImprintFilter_TriangulateOutputOn_71(GetCppThis());
	}
}
